<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complex Number Explorer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MathJax for nice equations -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f3f4f6;
        }
        canvas {
            cursor: crosshair;
            touch-action: none;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Main Container -->
    <div class="bg-white rounded-2xl shadow-xl w-full max-w-5xl overflow-hidden flex flex-col md:flex-row">
        
        <!-- Controls & Math Panel -->
        <div class="w-full md:w-1/3 p-8 bg-slate-50 border-r border-slate-100 flex flex-col">
            <div>
                <h1 class="text-2xl font-bold text-slate-800 mb-2">Complex Explorer</h1>
                <p class="text-sm text-slate-500 mb-6">The Argand Diagram.<br>Real (Re) vs Imaginary (Im).</p>

                <!-- Instructions / State -->
                <div id="instruction-box" class="bg-violet-100 text-violet-800 px-4 py-3 rounded-lg text-sm font-semibold mb-6 border border-violet-200">
                    Click to place z
                </div>

                <!-- Equation Display -->
                <div id="math-container" class="opacity-50 transition-opacity duration-300">
                    <!-- Standard Form -->
                    <div class="bg-white p-3 rounded-lg shadow-sm border border-slate-200 mb-4">
                        <p class="text-xs text-slate-400 uppercase font-bold mb-1">Rectangular Form</p>
                        <div id="rect-display" class="text-lg text-slate-700 font-mono">
                            \[ z = a + bi \]
                        </div>
                    </div>

                    <!-- Polar Form Calculation -->
                    <div class="bg-violet-600 text-white p-4 rounded-xl shadow-lg">
                        <p class="text-xs text-violet-200 uppercase font-bold mb-2">Polar Form</p>
                        <div id="polar-display" class="text-lg font-mono mb-2">
                            \[ z = r(\cos \theta + i \sin \theta) \]
                        </div>
                        <div class="text-xs text-violet-200 border-t border-violet-500 pt-2 mt-2">
                            \( r = |z| \) (Modulus)<br>
                            \( \theta = \arg(z) \) (Phase)
                        </div>
                    </div>
                </div>
            </div>

            <!-- "Teach to Learn" Note -->
            <div class="mt-auto pt-6 border-t border-slate-200">
                <h3 class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2">Concept Recall</h3>
                <p class="text-xs text-slate-600 leading-relaxed mb-2">
                    <span class="font-bold text-violet-600">i</span> is the unit where \( i^2 = -1 \).
                </p>
                <p class="text-xs text-slate-600 leading-relaxed mb-2">
                    This plane visualizes magnitude (length) and phase (angle), essential for AC circuits and waves.
                </p>
                <div class="flex items-center space-x-2 text-xs text-slate-500 mt-3">
                    <label class="flex items-center cursor-pointer">
                        <input type="checkbox" id="snap-toggle" class="form-checkbox text-violet-600 rounded" checked>
                        <span class="ml-2">Snap to Integers</span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Canvas Panel -->
        <div class="w-full md:w-2/3 p-4 bg-white relative flex items-center justify-center bg-grid-slate-100">
            <canvas id="complexCanvas" width="600" height="600" class="w-full max-w-[500px] h-auto rounded-lg shadow-inner bg-slate-50 border border-slate-200"></canvas>
            
            <!-- Floating Coordinates (Tooltip style) -->
            <div id="coords-tooltip" class="absolute pointer-events-none bg-slate-800 text-white text-xs px-2 py-1 rounded opacity-0 transition-opacity">
                0 + 0i
            </div>
        </div>
    </div>

    <script>
    // Wrapped in an IIFE (Immediately Invoked Function Expression) to prevent global variable collisions
    // like "Identifier 'z' has already been declared" when re-running the script.
    (function() {
        const canvas = document.getElementById('complexCanvas');
        const ctx = canvas.getContext('2d');
        const mathContainer = document.getElementById('math-container');
        const rectDisplay = document.getElementById('rect-display');
        const polarDisplay = document.getElementById('polar-display');
        const tooltip = document.getElementById('coords-tooltip');
        const snapToggle = document.getElementById('snap-toggle');

        // Logic State
        let z = null; // Object {a, b}
        const range = 10; 
        let gridSize = canvas.width / (range * 2); 

        // --- 1. Drawing Functions ---

        function transform(a, b) {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            return {
                x: cx + (a * gridSize),
                y: cy - (b * gridSize)
            };
        }

        function inverseTransform(px, py) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const rawA = (px * scaleX - cx) / gridSize;
            const rawB = (cy - py * scaleY) / gridSize;
            return { a: rawA, b: rawB };
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            ctx.lineWidth = 1;
            
            // Grid Lines
            ctx.strokeStyle = '#e2e8f0'; 
            ctx.beginPath();
            for(let i = 0; i <= range * 2; i++) {
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
            }
            ctx.stroke();

            // Axes
            ctx.strokeStyle = '#94a3b8'; 
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Real Axis (X)
            ctx.moveTo(0, cy);
            ctx.lineTo(canvas.width, cy);
            // Imaginary Axis (Y)
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, canvas.height);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#64748b';
            ctx.font = '12px sans-serif';
            
            // X Axis Labels (Re)
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for(let x = -range; x <= range; x += 2) {
                if(x === 0) continue;
                const pos = transform(x, 0);
                ctx.fillText(x.toString(), pos.x, cy + 5);
            }
            // Axis Title
            ctx.font = 'bold 12px sans-serif';
            ctx.fillText("Re (Real)", canvas.width - 30, cy + 10);

            // Y Axis Labels (Im)
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for(let y = -range; y <= range; y += 2) {
                if(y === 0) continue;
                const pos = transform(0, y);
                ctx.fillText(y.toString() + "i", cx - 5, pos.y);
            }
            // Axis Title
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText("Im (Imaginary)", cx + 10, 20);
        }

        function drawVector(target) {
            const origin = transform(0, 0);
            const tip = transform(target.a, target.b);

            // 1. Draw Angle Arc (Theta)
            const angle = Math.atan2(target.b, target.a);
            const radius = 30; // Radius of arc
            if (Math.abs(target.a) > 0.1 || Math.abs(target.b) > 0.1) { // Don't draw if at origin
                ctx.beginPath();
                ctx.strokeStyle = '#d8b4fe'; // violet-300
                ctx.lineWidth = 2;
                
                ctx.arc(origin.x, origin.y, radius, 0, -angle, angle > 0); // Draw counter-clockwise visually
                ctx.stroke();

                // Label Theta
                ctx.fillStyle = '#7c3aed';
                ctx.font = 'italic 12px serif';
                // Position label slightly past arc
                const labelAngle = -angle / 2; 
                ctx.fillText("Î¸", origin.x + (radius + 10) * Math.cos(labelAngle), origin.y + (radius + 10) * Math.sin(labelAngle));
            }


            // 2. Dashed Projections
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#94a3b8'; // slate-400
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Vertical projection to Re axis
            ctx.moveTo(tip.x, tip.y);
            ctx.lineTo(tip.x, origin.y);
            // Horizontal projection to Im axis
            ctx.moveTo(tip.x, tip.y);
            ctx.lineTo(origin.x, tip.y);
            ctx.stroke();
            ctx.setLineDash([]); 

            // 3. The Vector
            ctx.strokeStyle = '#7c3aed'; // violet-600
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(tip.x, tip.y);
            ctx.stroke();

            // Arrowhead
            const headLen = 10;
            const dx = tip.x - origin.x;
            const dy = tip.y - origin.y;
            const rot = Math.atan2(dy, dx);
            ctx.beginPath();
            ctx.moveTo(tip.x, tip.y);
            ctx.lineTo(tip.x - headLen * Math.cos(rot - Math.PI / 6), tip.y - headLen * Math.sin(rot - Math.PI / 6));
            ctx.lineTo(tip.x - headLen * Math.cos(rot + Math.PI / 6), tip.y - headLen * Math.sin(rot + Math.PI / 6));
            ctx.lineTo(tip.x, tip.y);
            ctx.fillStyle = '#7c3aed';
            ctx.fill();

            // 4. Point Label
            ctx.fillStyle = '#4c1d95'; // violet-900
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'bottom';
            ctx.fillText("z", tip.x + 10, tip.y - 10);
        }

        function updateMath(target) {
            const a = target.a;
            const b = target.b;

            // Rectangular Form
            const sign = b >= 0 ? '+' : '-';
            const bAbs = Math.abs(b);
            // Nicer formatting for integers
            const aStr = Number.isInteger(a) ? a : a.toFixed(1);
            const bStr = Number.isInteger(bAbs) ? bAbs : bAbs.toFixed(1);

            const latexRect = `\\[ z = ${aStr} ${sign} ${bStr}i \\]`;
            rectDisplay.innerHTML = latexRect;

            // Polar Form
            const r = Math.sqrt(a*a + b*b);
            let theta = Math.atan2(b, a); // Radians
            
            const rStr = r.toFixed(2);
            const thetaStr = theta.toFixed(2);
            const thetaDeg = (theta * 180 / Math.PI).toFixed(0);

            const latexPolar = `
                \\begin{align*} 
                |z| &= \\sqrt{${aStr}^2 + ${bStr}^2} \\approx ${rStr} \\\\
                \\theta &= \\tan^{-1}\\left(\\frac{${bStr}}{${aStr}}\\right) \\approx ${thetaStr}\\text{ rad } (${thetaDeg}^\\circ)
                \\end{align*}
            `;
            
            polarDisplay.innerHTML = latexPolar;
            
            if(window.MathJax) {
                MathJax.typesetPromise([rectDisplay, polarDisplay]);
            }
        }

        function render() {
            drawGrid();
            if(z) {
                drawVector(z);
            }
        }

        // --- 2. Interactions ---

        canvas.addEventListener('mousemove', (e) => {
            const raw = inverseTransform(e.offsetX, e.offsetY);
            let displayA = raw.a;
            let displayB = raw.b;

            if (snapToggle.checked) {
                displayA = Math.round(raw.a);
                displayB = Math.round(raw.b);
            } else {
                displayA = displayA.toFixed(1);
                displayB = displayB.toFixed(1);
            }

            const sign = displayB >= 0 ? '+' : ''; 
            
            tooltip.style.left = (e.pageX + 15) + 'px';
            tooltip.style.top = (e.pageY + 15) + 'px';
            tooltip.textContent = `${displayA} ${sign}${displayB}i`;
            tooltip.style.opacity = 1;
        });

        canvas.addEventListener('mouseleave', () => {
            tooltip.style.opacity = 0;
        });

        canvas.addEventListener('click', (e) => {
            const raw = inverseTransform(e.offsetX, e.offsetY);
            let a = raw.a;
            let b = raw.b;

            if (snapToggle.checked) {
                a = Math.round(a);
                b = Math.round(b);
            } else {
                a = parseFloat(a.toFixed(1));
                b = parseFloat(b.toFixed(1));
            }

            z = {a, b};
            
            mathContainer.classList.remove('opacity-50');
            updateMath(z);
            render();
        });

        render();
        window.addEventListener('resize', render);
    })();
    </script>
</body>
</html>