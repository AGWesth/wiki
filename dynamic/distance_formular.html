<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Distance Formula Explorer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MathJax for nice equations -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f3f4f6;
        }
        canvas {
            cursor: crosshair;
            touch-action: none;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Main Container -->
    <div class="bg-white rounded-2xl shadow-xl w-full max-w-5xl overflow-hidden flex flex-col md:flex-row">
        
        <!-- Controls & Math Panel -->
        <div class="w-full md:w-1/3 p-8 bg-slate-50 border-r border-slate-100 flex flex-col">
            <div>
                <h1 class="text-2xl font-bold text-slate-800 mb-2">Distance Explorer</h1>
                <p class="text-sm text-slate-500 mb-6">Visualizing the Pythagorean Theorem.</p>

                <!-- Instructions / State -->
                <div id="instruction-box" class="bg-yellow-100 text-yellow-800 px-4 py-3 rounded-lg text-sm font-semibold mb-6 border border-yellow-200">
                    Click to set Point 1
                </div>

                <!-- Equation Display -->
                <div id="math-container" class="opacity-50 transition-opacity duration-300">
                    <!-- General Formula -->
                    <div class="bg-white p-3 rounded-lg shadow-sm border border-slate-200 mb-4">
                        <p class="text-xs text-slate-400 uppercase font-bold mb-1">Distance Formula</p>
                        <div class="text-lg text-slate-700">
                            \[ d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} \]
                        </div>
                    </div>

                    <!-- Calculation -->
                    <div class="bg-emerald-600 text-white p-4 rounded-xl shadow-lg text-center">
                        <p class="text-xs text-emerald-200 uppercase font-bold mb-2">Calculation</p>
                        <div id="calc-display" class="text-lg font-mono overflow-x-auto">
                            \[ d = \text{...} \]
                        </div>
                    </div>
                </div>
            </div>

            <!-- "Teach to Learn" Note -->
            <div class="mt-auto pt-6 border-t border-slate-200">
                <h3 class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2">Concept Recall</h3>
                <p class="text-xs text-slate-600 leading-relaxed mb-2">
                    <span class="font-bold text-emerald-600">Distance</span> is the hypotenuse of the right triangle formed by the points.
                </p>
                <div class="flex items-center space-x-2 text-xs text-slate-500">
                    <label class="flex items-center cursor-pointer">
                        <input type="checkbox" id="snap-toggle" class="form-checkbox text-emerald-600 rounded" checked>
                        <span class="ml-2">Snap to Integers</span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Canvas Panel -->
        <div class="w-full md:w-2/3 p-4 bg-white relative flex items-center justify-center bg-grid-slate-100">
            <canvas id="slopeCanvas" width="600" height="600" class="w-full max-w-[500px] h-auto rounded-lg shadow-inner bg-slate-50 border border-slate-200"></canvas>
            
            <!-- Floating Coordinates (Tooltip style) -->
            <div id="coords-tooltip" class="absolute pointer-events-none bg-slate-800 text-white text-xs px-2 py-1 rounded opacity-0 transition-opacity">
                0, 0
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('slopeCanvas');
        const ctx = canvas.getContext('2d');
        const instructionBox = document.getElementById('instruction-box');
        const mathContainer = document.getElementById('math-container');
        const calcDisplay = document.getElementById('calc-display');
        const tooltip = document.getElementById('coords-tooltip');
        const snapToggle = document.getElementById('snap-toggle');

        // Logic State
        let points = []; 
        const range = 10; 
        let gridSize = canvas.width / (range * 2); 

        // --- 1. Drawing Functions ---

        function transform(x, y) {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            return {
                x: cx + (x * gridSize),
                y: cy - (y * gridSize)
            };
        }

        function inverseTransform(px, py) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const rawX = (px * scaleX - cx) / gridSize;
            const rawY = (cy - py * scaleY) / gridSize;
            return { x: rawX, y: rawY };
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            ctx.lineWidth = 1;
            
            // Grid Lines
            ctx.strokeStyle = '#e2e8f0'; 
            ctx.beginPath();
            for(let i = 0; i <= range * 2; i++) {
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
            }
            ctx.stroke();

            // Axes
            ctx.strokeStyle = '#94a3b8'; 
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(canvas.width, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, canvas.height);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#64748b';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for(let x = -range; x <= range; x += 2) {
                if(x === 0) continue;
                const pos = transform(x, 0);
                ctx.fillText(x.toString(), pos.x, cy + 5);
            }
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for(let y = -range; y <= range; y += 2) {
                if(y === 0) continue;
                const pos = transform(0, y);
                ctx.fillText(y.toString(), cx - 5, pos.y);
            }
        }

        function drawPoint(p, color, label) {
            const pos = transform(p.x, p.y);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1e293b'; 
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'bottom';
            ctx.fillText(label || `(${p.x}, ${p.y})`, pos.x + 10, pos.y - 10);
        }

        function drawVisuals(p1, p2) {
            const start = transform(p1.x, p1.y);
            const end = transform(p2.x, p2.y);
            const corner = transform(p2.x, p1.y); 

            // 1. Triangle Legs (Dashed)
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#64748b'; // slate-500
            ctx.lineWidth = 2;

            ctx.beginPath();
            // Horizontal leg (a)
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(corner.x, corner.y);
            // Vertical leg (b)
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
            ctx.setLineDash([]); 

            // 2. Hypotenuse (Distance Line)
            ctx.strokeStyle = '#059669'; // Emerald-600
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();

            // 3. Labels
            ctx.fillStyle = '#64748b';
            ctx.font = '12px sans-serif';
            
            // Leg Length Labels
            const runVal = Math.abs(p2.x - p1.x);
            const riseVal = Math.abs(p2.y - p1.y);
            const runMid = { x: (start.x + corner.x)/2, y: start.y };
            const riseMid = { x: corner.x, y: (corner.y + end.y)/2 };

            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            if (runVal > 0) ctx.fillText(runVal.toFixed(1), runMid.x, runMid.y + 8);

            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            if (riseVal > 0) ctx.fillText(riseVal.toFixed(1), riseMid.x + 8, riseMid.y);

            // Distance Label (Midpoint of hypotenuse)
            const distMid = { x: (start.x + end.x)/2, y: (start.y + end.y)/2 };
            ctx.fillStyle = '#059669'; // Emerald-600
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            // Offset slightly up and left to avoid line overlap
            ctx.fillText("d", distMid.x - 5, distMid.y - 5);
        }

        function updateMath(p1, p2) {
            const x1 = p1.x;
            const y1 = p1.y;
            const x2 = p2.x;
            const y2 = p2.y;

            // Differences
            const deltaX = x2 - x1;
            const deltaY = y2 - y1;
            
            // Squares
            const dxSq = Math.pow(deltaX, 2);
            const dySq = Math.pow(deltaY, 2);
            
            // Sum and Root
            const sum = dxSq + dySq;
            const dist = Math.sqrt(sum).toFixed(2);

            // Format nicely for display
            // We use \approx for the final result since we round it
            const latex = `
                \\begin{align*} 
                d &= \\sqrt{(${deltaX.toFixed(1)})^2 + (${deltaY.toFixed(1)})^2} \\\\
                  &= \\sqrt{${dxSq.toFixed(2)} + ${dySq.toFixed(2)}} \\\\
                  &= \\sqrt{${sum.toFixed(2)}} \\approx ${dist}
                \\end{align*}
            `;
            
            calcDisplay.innerHTML = latex;
            
            if(window.MathJax) {
                MathJax.typesetPromise([calcDisplay]);
            }
        }

        function render() {
            drawGrid();

            if(points.length > 0) {
                drawPoint(points[0], '#e11d48', 'P1'); 
            }

            if(points.length > 1) {
                drawVisuals(points[0], points[1]);
                drawPoint(points[1], '#4f46e5', 'P2'); 
            }
        }

        // --- 2. Interactions ---

        canvas.addEventListener('mousemove', (e) => {
            const raw = inverseTransform(e.offsetX, e.offsetY);
            let displayX = raw.x.toFixed(1);
            let displayY = raw.y.toFixed(1);

            if (snapToggle.checked) {
                displayX = Math.round(raw.x);
                displayY = Math.round(raw.y);
            }

            tooltip.style.left = (e.pageX + 15) + 'px';
            tooltip.style.top = (e.pageY + 15) + 'px';
            tooltip.textContent = `${displayX}, ${displayY}`;
            tooltip.style.opacity = 1;
        });

        canvas.addEventListener('mouseleave', () => {
            tooltip.style.opacity = 0;
        });

        canvas.addEventListener('click', (e) => {
            const raw = inverseTransform(e.offsetX, e.offsetY);
            let x = raw.x;
            let y = raw.y;

            if (snapToggle.checked) {
                x = Math.round(x);
                y = Math.round(y);
            } else {
                x = parseFloat(x.toFixed(1));
                y = parseFloat(y.toFixed(1));
            }

            if (points.length === 2) {
                points = [{x, y}];
                instructionBox.textContent = "Click to set Point 2";
                instructionBox.className = "bg-blue-100 text-blue-800 px-4 py-3 rounded-lg text-sm font-semibold mb-6 border border-blue-200";
                mathContainer.classList.add('opacity-50'); 
            } else if (points.length === 0) {
                points.push({x, y});
                instructionBox.textContent = "Click to set Point 2";
                instructionBox.className = "bg-blue-100 text-blue-800 px-4 py-3 rounded-lg text-sm font-semibold mb-6 border border-blue-200";
            } else {
                points.push({x, y});
                instructionBox.textContent = "Click anywhere to restart";
                instructionBox.className = "bg-green-100 text-green-800 px-4 py-3 rounded-lg text-sm font-semibold mb-6 border border-green-200";
                mathContainer.classList.remove('opacity-50');
                updateMath(points[0], points[1]);
            }

            render();
        });

        render();
        window.addEventListener('resize', render);

    </script>
</body>
</html>